============================================================
Bloc 1 â€” Import des librairies / Block 1 â€” Library imports
============================================================

```python
# Demo: Stochastic equation with memory and dynamic dimension
# Minimal Colab prototype

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.fft import rfft, rfftfreq

print("âœ… Libraries loaded. Upload your CSV in the next cell or use the example dataset.")

---
ðŸ‡«ðŸ‡· Ce bloc importe les bibliothÃ¨ques nÃ©cessaires : NumPy pour les calculs, Pandas pour les donnÃ©es, Matplotlib pour les graphiques, et SciPy pour lâ€™analyse spectrale.  
ðŸ‡¬ðŸ‡§ This block imports the required libraries: NumPy for calculations, Pandas for data handling, Matplotlib for plotting, and SciPy for spectral analysis.




# ðŸ“‚ Bloc 2 â€” Chargement et nettoyage automatique du CSV

import pandas as pd
import numpy as np

# Exemple intÃ©grÃ© si aucun fichier n'est uploadÃ©
example = pd.DataFrame({
    "time": np.linspace(0, 10, 500),
    "signal": np.sin(2*np.pi*0.5*np.linspace(0, 10, 500)) + 0.1*np.random.randn(500)
})
example.to_csv("example.csv", index=False)

print("ðŸ‘‰ You can upload your own CSV (at least 2 columns), or use the example.csv provided.")

# Upload via Colab
try:
    from google.colab import files
    uploaded = files.upload()
except ImportError:
    uploaded = {}

# Si un fichier est uploadÃ©, on le lit, sinon on prend l'exemple
if uploaded:
    filename = list(uploaded.keys())[0]
    df = pd.read_csv(filename)
else:
    df = pd.read_csv("example.csv")

# âœ… Normalisation automatique
if df.shape[1] < 2:
    raise ValueError("âŒ Your CSV must contain at least 2 columns.")

# On garde seulement les 2 premiÃ¨res colonnes
df = df.iloc[:, :2]

# On renomme en 't' et 'phi'
df.columns = ['t', 'phi']

# On supprime les valeurs manquantes
df = df.dropna().reset_index(drop=True)

# VÃ©rification des types numÃ©riques
if not np.issubdtype(df['t'].dtype, np.number) or not np.issubdtype(df['phi'].dtype, np.number):
    raise TypeError("âš ï¸ Error: Columns 't' and 'phi' must contain numeric values only.")

# Extraction des vecteurs
t = df['t'].values
phi = df['phi'].values

print("âœ… Data loaded and cleaned:", df.shape)
print(df.head())

---
ðŸ‡«ðŸ‡· Description (FranÃ§ais)
Ce bloc gÃ¨re automatiquement lâ€™importation et la prÃ©paration des donnÃ©es :  
- Il propose un jeu de donnÃ©es exemple (sinusoÃ¯de bruitÃ©e) si lâ€™utilisateur ne charge rien.  
- Il permet Ã  lâ€™utilisateur dâ€™uploader son propre fichier CSV.  
- Il standardise les donnÃ©es en ne gardant que les deux premiÃ¨res colonnes, renommÃ©es en t (temps) et phi (signal).  
- Il supprime les lignes vides et vÃ©rifie que les colonnes contiennent bien des valeurs numÃ©riques.  
- Enfin, il affiche un aperÃ§u des donnÃ©es nettoyÃ©es et les stocke dans deux vecteurs t et phi pour la suite de la dÃ©mo.  

ðŸ‘‰ RÃ©sultat : lâ€™utilisateur nâ€™a pas besoin de prÃ©parer ou trier son CSV, le bloc sâ€™occupe de tout.  

---

ðŸ‡¬ðŸ‡§ Description (English)
This block automatically handles data import and preparation:  
- It provides an example dataset (noisy sine wave) if the user does not upload anything.  
- It allows the user to upload their own CSV file.  
- It standardizes the data by keeping only the first two columns, renaming them t (time) and phi (signal).  
- It removes missing values and checks that both columns contain numeric values.  
- Finally, it displays a preview of the cleaned data and stores them in two vectors t and phi for the rest of the demo.  

ðŸ‘‰ Result: the user does not need to prepare or sort their CSV, the block takes care of everything.  

---
------------------------------------------------------------
Bloc 3 â€” Calcul de lâ€™amplitude observÃ©e / Block 3 â€” Observed amplitude
============================================================
# Amplitude observÃ©e = moyenne absolue sur les 20% finaux
phi_final = phi[int(0.8 * len(phi)):]
amp_obs = np.mean(np.abs(phi_final))
print("Observed amplitude:", amp_obs)

---
ðŸ‡«ðŸ‡· Ce bloc calcule lâ€™amplitude observÃ©e en prenant la moyenne absolue des 20% derniers points de la sÃ©rie.  
ðŸ‡¬ðŸ‡§ This block computes the observed amplitude by averaging the absolute values of the last 20% of the series.


------------------------------------------------------------
Bloc 4 â€” Estimation de Î±mean et amplitude thÃ©orique / Block 4 â€” Î±mean estimation and theoretical amplitude
============================================================

`python

Estimation simple de alpha_mean via frÃ©quence dominante
yf = rfft(phi - np.mean(phi))
xf = rfftfreq(len(phi), d=(t[1] - t[0]))
f_dom = xf[np.argmax(np.abs(yf))]
alphamean = fdom * np.var(phi)

Facteur dâ€™Ã©chelle ajustable
factor = 100.0
alphascaled = factor * alphamean
amptheo = np.sqrt(alphascaled) if alpha_scaled > 0 else 0

print("Î±mean (spectral):", alphamean)
print("Theoretical amplitude:", amp_theo)
`

ðŸ‡«ðŸ‡· Ce bloc estime Î±_mean Ã  partir de la frÃ©quence dominante du signal, applique un facteur dâ€™Ã©chelle, et calcule lâ€™amplitude thÃ©orique correspondante.  
ðŸ‡¬ðŸ‡§ This block estimates Î±_mean from the dominant frequency of the signal, applies a scaling factor, and computes the corresponding theoretical amplitude.

------------------------------------------------------------
Bloc 5 â€” Visualisation et erreur relative / Block 5 â€” Visualization and relative error
============================================================

`python

Erreur relative
error = abs(ampobs - amptheo) / amptheo if amptheo > 0 else None

Graphe
plt.figure(figsize=(10,5))
plt.plot(t, phi, label="Real signal")
plt.axhline(ampobs, color="green", linestyle="--", label=f"Observed amplitude = {ampobs:.2f}")
plt.axhline(amptheo, color="red", linestyle="--", label=f"Theoretical amplitude = {amptheo:.2f}")
plt.xlabel("Time")
plt.ylabel("Ï†(t)")
plt.title("Observed vs Theoretical Amplitude")
plt.legend()
plt.show()

print("Relative error:", f"{error:.2%}" if error is not None else "N/A")
`

ðŸ‡«ðŸ‡· Ce bloc trace le signal rÃ©el, lâ€™amplitude observÃ©e et lâ€™amplitude thÃ©orique, puis calcule lâ€™erreur relative entre les deux.  
ðŸ‡¬ðŸ‡§ This block plots the real signal, the observed amplitude, and the theoretical amplitude, then computes the relative error between them.
