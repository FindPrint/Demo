notebook démo, avec :  
- Code corrigé et uniforme (variables cohérentes).  
- Explications bilingues (🇫🇷 Français / 🇬🇧 English).  
- Une section finale d’explication d’utilisation en FR/EN pour guider les utilisateurs.  

---

<AttachedDocument filename="demoequationbilingue.txt" IsTruncated="false" status="ready">

============================================================
Bloc 1 — Import des librairies / Block 1 — Library imports
============================================================

`python

Demo: Stochastic equation with memory and dynamic dimension

Minimal Colab prototype

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.fft import rfft, rfftfreq

print("✅ Libraries loaded. Upload your CSV in the next cell or use the example dataset.")
`

🇫🇷 Ce bloc importe les bibliothèques nécessaires : NumPy pour les calculs, Pandas pour les données, Matplotlib pour les graphiques, et SciPy pour l’analyse spectrale.  
🇬🇧 This block imports the required libraries: NumPy for calculations, Pandas for data handling, Matplotlib for plotting, and SciPy for spectral analysis.


============================================================
Bloc 2 — Chargement et nettoyage automatique du CSV / Data loading & cleaning
============================================================

`python
import pandas as pd
import numpy as np

Exemple intégré si aucun fichier n'est uploadé
example = pd.DataFrame({
    "time": np.linspace(0, 10, 500),
    "signal": np.sin(2np.pi0.5np.linspace(0, 10, 500)) + 0.1np.random.randn(500)
})
example.to_csv("example.csv", index=False)

print("👉 You can upload your own CSV (at least 2 columns), or use the example.csv provided.")

Upload via Colab
try:
    from google.colab import files
    uploaded = files.upload()
except ImportError:
    uploaded = {}

Si un fichier est uploadé, on le lit, sinon on prend l'exemple
if uploaded:
    filename = list(uploaded.keys())[0]
    df = pd.read_csv(filename)
else:
    df = pd.read_csv("example.csv")

✅ Normalisation automatique
if df.shape[1] < 2:
    raise ValueError("❌ Your CSV must contain at least 2 columns.")

On garde seulement les 2 premières colonnes
df = df.iloc[:, :2]

On renomme en 't' et 'phi'
df.columns = ['t', 'phi']

On supprime les valeurs manquantes
df = df.dropna().reset_index(drop=True)

Vérification des types numériques
if not np.issubdtype(df['t'].dtype, np.number) or not np.issubdtype(df['phi'].dtype, np.number):
    raise TypeError("⚠️ Error: Columns 't' and 'phi' must contain numeric values only.")

Extraction des vecteurs
t = df['t'].values
phi = df['phi'].values

print("✅ Data loaded and cleaned:", df.shape)
print(df.head())
`

🇫🇷 Ce bloc gère automatiquement l’importation et la préparation des données : jeu de données exemple si rien n’est uploadé, upload CSV possible, standardisation en t et phi, suppression des valeurs manquantes, vérification des types numériques.  
🇬🇧 This block automatically handles data import and preparation: example dataset if nothing is uploaded, CSV upload option, standardization into t and phi, removal of missing values, numeric type checking.


============================================================
Bloc 3 — Calcul de l’amplitude observée / Block 3 — Observed amplitude
============================================================

`python

Amplitude observée = moyenne absolue sur les 20% finaux
phi_final = phi[int(0.8 * len(phi)):]
ampobs = np.mean(np.abs(phifinal))
print("Observed amplitude:", amp_obs)
`

🇫🇷 Ce bloc calcule l’amplitude observée en prenant la moyenne absolue des 20% derniers points de la série.  
🇬🇧 This block computes the observed amplitude by averaging the absolute values of the last 20% of the series.


============================================================
Bloc 4 — Estimation de αmean et amplitude théorique / Block 4 — αmean estimation and theoretical amplitude
============================================================

`python

Estimation simple de alpha_mean via fréquence dominante
yf = rfft(phi - np.mean(phi))
xf = rfftfreq(len(phi), d=(t[1] - t[0]))
f_dom = xf[np.argmax(np.abs(yf))]
alphamean = fdom * np.var(phi)

Facteur d’échelle ajustable
factor = 100.0
alphascaled = factor * alphamean
amptheo = np.sqrt(alphascaled) if alpha_scaled > 0 else 0

print("αmean (spectral):", alphamean)
print("Theoretical amplitude:", amp_theo)
`

🇫🇷 Ce bloc estime α_mean à partir de la fréquence dominante du signal, applique un facteur d’échelle, et calcule l’amplitude théorique correspondante.  
🇬🇧 This block estimates α_mean from the dominant frequency of the signal, applies a scaling factor, and computes the corresponding theoretical amplitude.


============================================================
Bloc 5 — Visualisation et erreur relative / Block 5 — Visualization and relative error
============================================================

`python

Erreur relative
error = abs(ampobs - amptheo) / amptheo if amptheo > 0 else None

Graphe
plt.figure(figsize=(10,5))
plt.plot(t, phi, label="Real signal")
plt.axhline(ampobs, color="green", linestyle="--", label=f"Observed amplitude = {ampobs:.2f}")
plt.axhline(amptheo, color="red", linestyle="--", label=f"Theoretical amplitude = {amptheo:.2f}")
plt.xlabel("Time")
plt.ylabel("φ(t)")
plt.title("Observed vs Theoretical Amplitude")
plt.legend()
plt.show()

print("Relative error:", f"{error:.2%}" if error is not None else "N/A")
`

🇫🇷 Ce bloc trace le signal réel, l’amplitude observée et l’amplitude théorique, puis calcule l’erreur relative entre les deux.  
🇬🇧 This block plots the real signal, the observed amplitude, and the theoretical amplitude, then computes the relative error between them.


============================================================
Explication d’utilisation / Usage instructions
============================================================

🇫🇷 Comment utiliser ce notebook :  
1. Ouvrez le notebook dans Google Colab (via le badge Colab dans le README).  
2. Cliquez sur Runtime → Run all pour exécuter toutes les cellules.  
3. Vous pouvez soit :  
   - utiliser le dataset exemple généré automatiquement (example.csv),  
   - uploader votre propre CSV (au moins 2 colonnes : temps, valeur).  
4. Le notebook calcule :  
   - l’amplitude observée,  
   - α_mean (méthode spectrale),  
   - l’amplitude théorique,  
   - l’erreur relative,  
   - et trace un graphe comparatif.  

👉 Résultat : vous obtenez une comparaison directe entre vos données et la prédiction du modèle.  

---

🇬🇧 How to use this notebook:  
1. Open the notebook in Google Colab (via the Colab badge in the README).  
2. Click Runtime → Run all to execute all cells.  
3. You can either:  
   - use the automatically generated example dataset (example.csv),  
   - upload your own CSV (at least 2 columns: time, value).  
4. The notebook computes:  
   - the observed amplitude,  
   - α_mean (spectral method),  
   - the theoretical amplitude,  
   - the relative error,  
   - and plots a comparison graph.  

👉 Result: you get a direct comparison between your data and the model’s prediction.  

</AttachedDocument>

---

