notebook dÃ©mo, avec :  
- Code corrigÃ© et uniforme (variables cohÃ©rentes).  
- Explications bilingues (ðŸ‡«ðŸ‡· FranÃ§ais / ðŸ‡¬ðŸ‡§ English).  
- Une section finale dâ€™explication dâ€™utilisation en FR/EN pour guider les utilisateurs.  

---

<AttachedDocument filename="demoequationbilingue.txt" IsTruncated="false" status="ready">

============================================================
Bloc 1 â€” Import des librairies / Block 1 â€” Library imports
============================================================

`python

Demo: Stochastic equation with memory and dynamic dimension

Minimal Colab prototype

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.fft import rfft, rfftfreq

print("âœ… Libraries loaded. Upload your CSV in the next cell or use the example dataset.")
`

ðŸ‡«ðŸ‡· Ce bloc importe les bibliothÃ¨ques nÃ©cessaires : NumPy pour les calculs, Pandas pour les donnÃ©es, Matplotlib pour les graphiques, et SciPy pour lâ€™analyse spectrale.  
ðŸ‡¬ðŸ‡§ This block imports the required libraries: NumPy for calculations, Pandas for data handling, Matplotlib for plotting, and SciPy for spectral analysis.


============================================================
Bloc 2 â€” Chargement et nettoyage automatique du CSV / Data loading & cleaning
============================================================

`python
import pandas as pd
import numpy as np

Exemple intÃ©grÃ© si aucun fichier n'est uploadÃ©
example = pd.DataFrame({
    "time": np.linspace(0, 10, 500),
    "signal": np.sin(2np.pi0.5np.linspace(0, 10, 500)) + 0.1np.random.randn(500)
})
example.to_csv("example.csv", index=False)

print("ðŸ‘‰ You can upload your own CSV (at least 2 columns), or use the example.csv provided.")

Upload via Colab
try:
    from google.colab import files
    uploaded = files.upload()
except ImportError:
    uploaded = {}

Si un fichier est uploadÃ©, on le lit, sinon on prend l'exemple
if uploaded:
    filename = list(uploaded.keys())[0]
    df = pd.read_csv(filename)
else:
    df = pd.read_csv("example.csv")

âœ… Normalisation automatique
if df.shape[1] < 2:
    raise ValueError("âŒ Your CSV must contain at least 2 columns.")

On garde seulement les 2 premiÃ¨res colonnes
df = df.iloc[:, :2]

On renomme en 't' et 'phi'
df.columns = ['t', 'phi']

On supprime les valeurs manquantes
df = df.dropna().reset_index(drop=True)

VÃ©rification des types numÃ©riques
if not np.issubdtype(df['t'].dtype, np.number) or not np.issubdtype(df['phi'].dtype, np.number):
    raise TypeError("âš ï¸ Error: Columns 't' and 'phi' must contain numeric values only.")

Extraction des vecteurs
t = df['t'].values
phi = df['phi'].values

print("âœ… Data loaded and cleaned:", df.shape)
print(df.head())
`

ðŸ‡«ðŸ‡· Ce bloc gÃ¨re automatiquement lâ€™importation et la prÃ©paration des donnÃ©es : jeu de donnÃ©es exemple si rien nâ€™est uploadÃ©, upload CSV possible, standardisation en t et phi, suppression des valeurs manquantes, vÃ©rification des types numÃ©riques.  
ðŸ‡¬ðŸ‡§ This block automatically handles data import and preparation: example dataset if nothing is uploaded, CSV upload option, standardization into t and phi, removal of missing values, numeric type checking.


============================================================
Bloc 3 â€” Calcul de lâ€™amplitude observÃ©e / Block 3 â€” Observed amplitude
============================================================

`python

Amplitude observÃ©e = moyenne absolue sur les 20% finaux
phi_final = phi[int(0.8 * len(phi)):]
ampobs = np.mean(np.abs(phifinal))
print("Observed amplitude:", amp_obs)
`

ðŸ‡«ðŸ‡· Ce bloc calcule lâ€™amplitude observÃ©e en prenant la moyenne absolue des 20% derniers points de la sÃ©rie.  
ðŸ‡¬ðŸ‡§ This block computes the observed amplitude by averaging the absolute values of the last 20% of the series.


============================================================
Bloc 4 â€” Estimation de Î±mean et amplitude thÃ©orique / Block 4 â€” Î±mean estimation and theoretical amplitude
============================================================

`python

Estimation simple de alpha_mean via frÃ©quence dominante
yf = rfft(phi - np.mean(phi))
xf = rfftfreq(len(phi), d=(t[1] - t[0]))
f_dom = xf[np.argmax(np.abs(yf))]
alphamean = fdom * np.var(phi)

Facteur dâ€™Ã©chelle ajustable
factor = 100.0
alphascaled = factor * alphamean
amptheo = np.sqrt(alphascaled) if alpha_scaled > 0 else 0

print("Î±mean (spectral):", alphamean)
print("Theoretical amplitude:", amp_theo)
`

ðŸ‡«ðŸ‡· Ce bloc estime Î±_mean Ã  partir de la frÃ©quence dominante du signal, applique un facteur dâ€™Ã©chelle, et calcule lâ€™amplitude thÃ©orique correspondante.  
ðŸ‡¬ðŸ‡§ This block estimates Î±_mean from the dominant frequency of the signal, applies a scaling factor, and computes the corresponding theoretical amplitude.


============================================================
Bloc 5 â€” Visualisation et erreur relative / Block 5 â€” Visualization and relative error
============================================================

`python

Erreur relative
error = abs(ampobs - amptheo) / amptheo if amptheo > 0 else None

Graphe
plt.figure(figsize=(10,5))
plt.plot(t, phi, label="Real signal")
plt.axhline(ampobs, color="green", linestyle="--", label=f"Observed amplitude = {ampobs:.2f}")
plt.axhline(amptheo, color="red", linestyle="--", label=f"Theoretical amplitude = {amptheo:.2f}")
plt.xlabel("Time")
plt.ylabel("Ï†(t)")
plt.title("Observed vs Theoretical Amplitude")
plt.legend()
plt.show()

print("Relative error:", f"{error:.2%}" if error is not None else "N/A")
`

ðŸ‡«ðŸ‡· Ce bloc trace le signal rÃ©el, lâ€™amplitude observÃ©e et lâ€™amplitude thÃ©orique, puis calcule lâ€™erreur relative entre les deux.  
ðŸ‡¬ðŸ‡§ This block plots the real signal, the observed amplitude, and the theoretical amplitude, then computes the relative error between them.


============================================================
Explication dâ€™utilisation / Usage instructions
============================================================

ðŸ‡«ðŸ‡· Comment utiliser ce notebook :  
1. Ouvrez le notebook dans Google Colab (via le badge Colab dans le README).  
2. Cliquez sur Runtime â†’ Run all pour exÃ©cuter toutes les cellules.  
3. Vous pouvez soit :  
   - utiliser le dataset exemple gÃ©nÃ©rÃ© automatiquement (example.csv),  
   - uploader votre propre CSV (au moins 2 colonnes : temps, valeur).  
4. Le notebook calcule :  
   - lâ€™amplitude observÃ©e,  
   - Î±_mean (mÃ©thode spectrale),  
   - lâ€™amplitude thÃ©orique,  
   - lâ€™erreur relative,  
   - et trace un graphe comparatif.  

ðŸ‘‰ RÃ©sultat : vous obtenez une comparaison directe entre vos donnÃ©es et la prÃ©diction du modÃ¨le.  

---

ðŸ‡¬ðŸ‡§ How to use this notebook:  
1. Open the notebook in Google Colab (via the Colab badge in the README).  
2. Click Runtime â†’ Run all to execute all cells.  
3. You can either:  
   - use the automatically generated example dataset (example.csv),  
   - upload your own CSV (at least 2 columns: time, value).  
4. The notebook computes:  
   - the observed amplitude,  
   - Î±_mean (spectral method),  
   - the theoretical amplitude,  
   - the relative error,  
   - and plots a comparison graph.  

ðŸ‘‰ Result: you get a direct comparison between your data and the modelâ€™s prediction.  

</AttachedDocument>

---

